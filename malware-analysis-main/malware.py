import subprocess
import pefile
import math
from collections import Counter
import os
import yara

def write_output(output, content):
    if output:
        with open(output, 'w') as f:
            f.write(content)
    else:
        print(content)

def extract_strings(file_path, output=None):
    try:
        result = subprocess.run(['strings', file_path], capture_output=True, text=True)
        write_output(output, result.stdout)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")

def calculate_entropy(file_path, output=None):
    try:
        with open(file_path, 'rb') as f:
            byteArr = f.read()
            fileSize = len(byteArr)
            freqList = Counter(byteArr)

            entropy = 0.0
            for freq in freqList.values():
                prob = freq / fileSize
                entropy -= prob * math.log2(prob)

            result = f'Entropy: {entropy}'
            write_output(output, result)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")

def enumerate_headers(file_path, output=None):
    try:
        pe = pefile.PE(file_path)
        info = []
        info.append(pe.dump_info())
        result = "\n".join(info)
        write_output(output, result)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")

def determine_language(file_path, output=None):
    try:
        pe = pefile.PE(file_path)
        languages = {
            'Visual Basic': ['MSVBVM60.DLL'],
            'Visual C++': ['MSVCRT.DLL', '.idata'],
            'Borland Delphi': ['borlndmm.dll', '.borland'],
            'Go': ['.rdata', '__go_'],
            'Rust': ['.rdata', 'rust_eh'],
            'Python': ['.idata', 'python'],
        }

        found_languages = []

        # Check for common language indicators in imported DLLs and section names
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode().lower()
            for language, indicators in languages.items():
                if any(indicator.lower() in dll_name for indicator in indicators):
                    found_languages.append(language)

        for section in pe.sections:
            section_name = section.Name.decode().strip('\x00').lower()
            for language, indicators in languages.items():
                if any(indicator.lower() in section_name for indicator in indicators):
                    found_languages.append(language)

        found_languages = list(set(found_languages))  # Remove duplicates

        if found_languages:
            result = f'Possible programming languages: {", ".join(found_languages)}'
        else:
            result = 'Could not determine the programming language.'

        write_output(output, result)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")

def analyze_sections(file_path, output=None):
    try:
        pe = pefile.PE(file_path)
        sections_info = []

        for section in pe.sections:
            sections_info.append(
                f"Name: {section.Name.decode().strip()}\n"
                f"Virtual Address: {hex(section.VirtualAddress)}\n"
                f"Size of Raw Data: {hex(section.SizeOfRawData)}\n"
                f"Characteristics: {hex(section.Characteristics)}\n"
            )

        result = "\n".join(sections_info)
        write_output(output, result)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")

def detect_packer(file_path, output=None):
    known_packers = {
        "UPX": [b"UPX0", b"UPX1", b"UPX2"],
        "ASPack": [b".aspack"]
    }

    try:
        with open(file_path, 'rb') as f:
            file_data = f.read()

            found_packers = []
            for packer, signatures in known_packers.items():
                for signature in signatures:
                    if signature in file_data:
                        found_packers.append(packer)

            if found_packers:
                result = f"Detected packers/obfuscators: {', '.join(found_packers)}"
            else:
                result = "No known packers/obfuscators detected."

            write_output(output, result)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")

import yara
import os

def compile_yara_rules_from_directory(directory_path):
    rules = []
    for file_name in os.listdir(directory_path):
        if file_name.endswith('.yar') or file_name.endswith('.yara'):
            file_path = os.path.join(directory_path, file_name)
            try:
                rule = yara.compile(filepath=file_path)
                rules.append(rule)
            except Exception as e:
                print(f"Failed to compile YARA rules from {file_path}: {e}")
    return rules

def search_yara_signatures(file_path, rules_directory, output=None):
    try:
        rules = compile_yara_rules_from_directory(rules_directory)
        matches = []

        for rule in rules:
            match = rule.match(filepath=file_path)
            if match:
                matches.extend(match)

        matches_info = [str(match) for match in matches]

        result = "\n".join(matches_info) if matches_info else "No YARA signatures matched."
        write_output(output, result)
    except Exception as e:
        write_output(output, f"An error occurred: {e}")
